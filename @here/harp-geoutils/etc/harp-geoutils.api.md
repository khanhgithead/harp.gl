## API Report File for "@here/harp-geoutils"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Frustum } from 'three';
import { Matrix4 } from 'three';
import { Plane } from 'three';
import { Ray } from 'three';
import * as THREE from 'three';
import { Vector3 } from 'three';

// @public
export interface Box3Like {
    readonly max: Vector3Like;
    readonly min: Vector3Like;
}

// @public (undocumented)
export class EarthConstants {
    static EQUATORIAL_CIRCUMFERENCE: number;
    static EQUATORIAL_RADIUS: number;
    static MAX_BUILDING_HEIGHT: number;
    static MAX_ELEVATION: number;
    static MIN_ELEVATION: number;
}

// @public
export const equirectangularProjection: Projection;

// @public
export class FlatTileBoundingBoxGenerator {
    constructor(tilingScheme: TilingScheme, minElevation?: number, maxElevation?: number);
    getGeoBox(tileKey: TileKey): GeoBox;
    getWorldBox(tileKey: TileKey, result?: Box3Like): Box3Like;
    // (undocumented)
    readonly maxElevation: number;
    // (undocumented)
    readonly minElevation: number;
    get projection(): Projection;
    get subdivisionScheme(): SubdivisionScheme;
    // (undocumented)
    readonly tilingScheme: TilingScheme;
}

// @public
export class GeoBox {
    constructor(southWest: GeoCoordinates, northEast: GeoCoordinates);
    // (undocumented)
    get altitudeSpan(): number | undefined;
    get center(): GeoCoordinates;
    clone(): GeoBox;
    contains(point: GeoCoordinates): boolean;
    get east(): number;
    static fromCoordinates(southWest: GeoCoordinates, northEast: GeoCoordinates): GeoBox;
    growToContain(point: GeoCoordinates): void;
    get latitudeSpan(): number;
    // @deprecated
    get latitudeSpanInDegrees(): number;
    get latitudeSpanInRadians(): number;
    get longitudeSpan(): number;
    // @deprecated
    get longitudeSpanInDegrees(): number;
    get longitudeSpanInRadians(): number;
    get maxAltitude(): number | undefined;
    get minAltitude(): number | undefined;
    get north(): number;
    // (undocumented)
    readonly northEast: GeoCoordinates;
    get south(): number;
    // (undocumented)
    readonly southWest: GeoCoordinates;
    get west(): number;
}

// @public
export class GeoCoordinates implements GeoCoordinatesLike {
    constructor(latitude: number, longitude: number, altitude?: number | undefined);
    // (undocumented)
    altitude?: number | undefined;
    clone(): GeoCoordinates;
    copy(other: GeoCoordinatesLike): GeoCoordinates;
    equals(other: GeoCoordinatesLike): boolean;
    static fromDegrees(latitude: number, longitude: number, altitude?: number): GeoCoordinates;
    static fromGeoPoint(geoPoint: GeoPointLike): GeoCoordinates;
    static fromLatLng(latLng: LatLngLike): GeoCoordinates;
    static fromObject(geoPoint: GeoCoordLike): GeoCoordinates;
    static fromRadians(latitude: number, longitude: number, altitude?: number): GeoCoordinates;
    isValid(): boolean;
    get lat(): number;
    // (undocumented)
    latitude: number;
    // @deprecated
    get latitudeInDegrees(): number;
    get latitudeInRadians(): number;
    get lng(): number;
    // (undocumented)
    longitude: number;
    // @deprecated
    get longitudeInDegrees(): number;
    get longitudeInRadians(): number;
    normalized(): GeoCoordinates;
    toGeoPoint(): GeoPointLike;
    toLatLng(): LatLngLike;
}

// @public
export interface GeoCoordinatesLike {
    altitude?: number;
    latitude: number;
    longitude: number;
}

// @public
export type GeoCoordLike = GeoPointLike | GeoCoordinatesLike | LatLngLike;

// @public
export type GeoPointLike = [number, number, number?];

// @public
export const halfQuadTreeSubdivisionScheme: SubdivisionScheme;

// @public
export const hereTilingScheme: TilingScheme;

// @public
export const identityProjection: Projection;

// @public
export function isBox3Like(object: {}): object is Box3Like;

// @public
export function isGeoCoordinatesLike(object: any): object is GeoCoordinatesLike;

// @public
export function isGeoPointLike(geoPoint: any): geoPoint is GeoPointLike;

// @public
export function isLatLngLike(object: any): object is LatLngLike;

// @public
export function isOrientedBox3Like(object: {}): object is OrientedBox3Like;

// @public
export function isTransformLike(object: {}): object is TransformLike;

// @public (undocumented)
export function isVector3Like(v: any): v is Vector3Like;

// @public
export interface LatLngLike {
    lat: number;
    lng: number;
}

// @public (undocumented)
export namespace MathUtils {
    export function angleDistanceDeg(a: number, b: number): number;
    export function interpolateAnglesDeg(p0: number, p1: number, t: number): number;
    // @deprecated
    export function newEmptyBox3(): Box3Like;
    const // @deprecated
    degToRad: typeof THREE.MathUtils.degToRad;
    const // @deprecated
    radToDeg: typeof THREE.MathUtils.radToDeg;
    const // @deprecated
    clamp: typeof THREE.MathUtils.clamp;
    export function newVector3(x: number, y: number, z: number): Vector3Like;
    export function newVector3<Vector extends Vector3Like>(x: number, y: number, z: number, v: Vector): Vector;
    export function normalizeAngleDeg(a: number): number;
}

// @public (undocumented)
export class MercatorConstants {
    // (undocumented)
    static readonly MAXIMUM_LATITUDE: number;
}

// @public
export const mercatorProjection: Projection;

// @public
export const mercatorTilingScheme: TilingScheme;

// @public
export const normalizedEquirectangularProjection: Projection;

// @public (undocumented)
export class OrientedBox3 implements OrientedBox3Like {
    constructor();
    constructor(position: Vector3, rotationMatrix: Matrix4, extents: Vector3);
    clone(): OrientedBox3;
    contains(point: Vector3): boolean;
    copy(other: OrientedBox3): void;
    distanceToPoint(point: Vector3): number;
    distanceToPointSquared(point: Vector3): number;
    readonly extents: Vector3;
    getCenter(center?: Vector3): Vector3;
    getRotationMatrix(matrix?: Matrix4): Matrix4;
    getSize(size?: Vector3): Vector3;
    intersects(frustumOrPlanes: Plane[] | Frustum): boolean;
    intersectsRay(ray: Ray): number | undefined;
    readonly position: Vector3;
    readonly xAxis: Vector3;
    readonly yAxis: Vector3;
    readonly zAxis: Vector3;
}

// @public
export interface OrientedBox3Like extends TransformLike {
    readonly extents: Vector3Like;
}

// @public
export const polarTilingScheme: TilingScheme;

// @public
export abstract class Projection {
    constructor(unitScale: number);
    abstract getScaleFactor(worldPoint: Vector3Like): number;
    abstract groundDistance(worldPoint: Vector3Like): number;
    localTangentSpace(geoPoint: GeoCoordinatesLike, result: TransformLike): TransformLike;
    abstract projectBox(geoBox: GeoBox): Box3Like;
    abstract projectBox<WorldBoundingBox extends Box3Like | OrientedBox3Like>(geoBox: GeoBox, result: WorldBoundingBox): WorldBoundingBox;
    abstract projectPoint<WorldCoordinates extends Vector3Like>(geoPoint: GeoCoordinatesLike, result?: WorldCoordinates): WorldCoordinates;
    reprojectPoint(sourceProjection: Projection, worldPos: Vector3Like): Vector3Like;
    reprojectPoint<WorldCoordinates extends Vector3Like>(sourceProjection: Projection, worldPos: Vector3Like, result: WorldCoordinates): WorldCoordinates;
    abstract scalePointToSurface(worldPoint: Vector3Like): Vector3Like;
    abstract surfaceNormal(worldPoint: Vector3Like): Vector3Like;
    abstract surfaceNormal<Normal extends Vector3Like>(worldPoint: Vector3Like, result: Normal): Normal;
    abstract get type(): ProjectionType;
    // (undocumented)
    readonly unitScale: number;
    abstract unprojectAltitude(worldPoint: Vector3Like): number;
    abstract unprojectBox(worldBox: Box3Like): GeoBox;
    abstract unprojectPoint(worldPoint: Vector3Like): GeoCoordinates;
    abstract worldExtent<Bounds extends Box3Like>(minElevation: number, maxElevation: number, result?: Bounds): Bounds;
}

// @public
export enum ProjectionType {
    Planar = 0,
    Spherical = 1
}

// @public
export class QuadTree {
    constructor(tilingScheme: TilingScheme);
    // (undocumented)
    readonly tilingScheme: TilingScheme;
    visit(accept: (tileKey: TileKey, geoBox: GeoBox) => boolean): void;
    visitTileKey(tileKey: TileKey, accept: (tileKey: TileKey, geoBox: GeoBox) => boolean): void;
}

// @public
export const quadTreeSubdivisionScheme: SubdivisionScheme;

// @public (undocumented)
export const sphereProjection: Projection;

// @public
export interface SubdivisionScheme {
    getLevelDimensionX(level: number): number;
    getLevelDimensionY(level: number): number;
    getSubdivisionX(level: number): number;
    getSubdivisionY(level: number): number;
}

// @public (undocumented)
export class SubTiles implements Iterable<TileKey> {
    // (undocumented)
    [Symbol.iterator](): Iterator<TileKey>;
    constructor(tileKey: TileKey, sizeX: number, sizeY: number);
    // (undocumented)
    sizeX: number;
    // (undocumented)
    sizeY: number;
    // (undocumented)
    tileKey: TileKey;
}

// @public (undocumented)
export namespace SubTiles {
    // (undocumented)
    export function RowColumnIterator(parentKey: TileKey, sizeX: number, sizeY: number): Iterator<TileKey>;
    // (undocumented)
    export function ZCurveIterator(parentKey: TileKey): Iterator<TileKey>;
}

// @public
export class TileKey {
    constructor(row: number, column: number, level: number);
    addedSubHereTile(sub: string): TileKey;
    addedSubKey(sub: string): TileKey;
    static atCoords(level: number, coordX: number, coordY: number, totalWidth: number, totalHeight: number): TileKey;
    changedLevelBy(delta: number): TileKey;
    changedLevelTo(level: number): TileKey;
    // (undocumented)
    readonly column: number;
    columnCount(): number;
    static columnsAtLevel(level: number): number;
    equals(qnr: TileKey): boolean;
    static fromHereTile(quadkey64: string): TileKey;
    static fromMortonCode(quadKey64: number): TileKey;
    static fromQuadKey(quadkey: string): TileKey;
    static fromRowColumnLevel(row: number, column: number, level: number): TileKey;
    getSubHereTile(delta: number): string;
    // (undocumented)
    readonly level: number;
    mortonCode(): number;
    parent(): TileKey;
    static parentMortonCode(mortonCode: number): number;
    // (undocumented)
    readonly row: number;
    rowCount(): number;
    static rowsAtLevel(level: number): number;
    toHereTile(): string;
    toQuadKey(): string;
}

// @public (undocumented)
export class TileKeyUtils {
    // (undocumented)
    static geoCoordinatesToTileKey(tilingScheme: TilingScheme, geoPoint: GeoCoordinatesLike, level: number): TileKey | null;
    // (undocumented)
    static geoRectangleToTileKeys(tilingScheme: TilingScheme, geoBox: GeoBox, level: number): TileKey[];
    // (undocumented)
    static worldCoordinatesToTileKey(tilingScheme: TilingScheme, worldPoint: Vector3Like, level: number): TileKey | null;
}

// @public (undocumented)
export class TileTreeTraverse {
    constructor(subdivisionScheme: SubdivisionScheme);
    // (undocumented)
    subTiles(tileKey: TileKey): Iterable<TileKey>;
}

// @public
export class TilingScheme {
    constructor(subdivisionScheme: SubdivisionScheme, projection: Projection);
    // (undocumented)
    readonly boundingBoxGenerator: FlatTileBoundingBoxGenerator;
    getGeoBox(tileKey: TileKey): GeoBox;
    getSubTileKeys(tileKey: TileKey): Iterable<TileKey>;
    getTileKey(geoPoint: GeoCoordinatesLike, level: number): TileKey | null;
    getTileKeys(geoBox: GeoBox, level: number): TileKey[];
    getWorldBox(tileKey: TileKey, result?: Box3Like): Box3Like;
    // (undocumented)
    readonly projection: Projection;
    // (undocumented)
    readonly subdivisionScheme: SubdivisionScheme;
    // (undocumented)
    readonly tileTreeTraverse: TileTreeTraverse;
}

// @public
export interface TransformLike {
    readonly position: Vector3Like;
    readonly xAxis: Vector3Like;
    readonly yAxis: Vector3Like;
    readonly zAxis: Vector3Like;
}

// @public
export const transverseMercatorProjection: Projection;

// @public (undocumented)
export class TransverseMercatorUtils {
    static alignLatitude(points: GeoCoordinatesLike[], referencePoint: GeoCoordinatesLike): void;
    static alignLongitude(points: GeoCoordinatesLike[], referencePoint: GeoCoordinatesLike): void;
    // (undocumented)
    static POLE_EDGE: number;
    // (undocumented)
    static POLE_EDGE_DEG: number;
    // (undocumented)
    static POLE_RADIUS: number;
    // (undocumented)
    static POLE_RADIUS_SQ: number;
}

// @public
export interface Vector3Like {
    x: number;
    y: number;
    z: number;
}

// @public
export const webMercatorProjection: Projection;

// @public
export const webMercatorTilingScheme: TilingScheme;


// (No @packageDocumentation comment for this package)

```
